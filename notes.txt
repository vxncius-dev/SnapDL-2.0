# implementar logica de permissão

import flet as ft
import requests
import os

def main(page: ft.Page):
    page.title = "SnapDL - Downloader"
    
    # Handler de permissões
    ph = ft.PermissionHandler()
    page.overlay.append(ph)
    
    # Input pra URL do download
    url_input = ft.TextField(label="URL do arquivo", width=300)
    
    # Botão pra pedir permissões e iniciar download
    btn_download = ft.ElevatedButton(
        "Baixar Arquivo",
        on_click=lambda e: handle_download(page, ph, url_input.value)
    )
    
    # Botão pra abrir configurações, caso permissões sejam negadas
    btn_settings = ft.ElevatedButton(
        "Abrir Configurações",
        on_click=lambda e: ph.open_app_settings()
    )
    
    page.add(url_input, btn_download, btn_settings)

def handle_download(page, ph, url):
    # Verifica permissões necessárias
    storage_perm = ph.check_permission(ft.PermissionType.STORAGE)
    notification_perm = ph.check_permission(ft.PermissionType.NOTIFICATION)
    
    if storage_perm != ft.PermissionState.GRANTED:
        ph.request_permission(ft.PermissionType.STORAGE)
        page.add(ft.Text("Por favor, permita acesso ao armazenamento."))
        return
    
    if notification_perm != ft.PermissionState.GRANTED:
        ph.request_permission(ft.PermissionType.NOTIFICATION)
        page.add(ft.Text("Por favor, permita notificações."))
        return
    
    # Diretório pra salvar (ajusta conforme plataforma)
    save_path = os.path.join(os.path.expanduser("~"), "Downloads", "snapdl_file")
    
    try:
        # Faz o download (exemplo com requests)
        response = requests.get(url, stream=True)
        if response.status_code == 200:
            with open(save_path, "wb") as f:
                for chunk in response.iter_content(chunk_size=8192):
                    f.write(chunk)
            page.add(ft.Text(f"Download concluído: {save_path}"))
            
            # Envia notificação
            page.show_snack_bar(ft.SnackBar(content=ft.Text("Download concluído!")))
        else:
            page.add(ft.Text("Erro no download: URL inválida"))
    except Exception as e:
        page.add(ft.Text(f"Erro: {str(e)}"))

ft.app(target=main)

# Adiciona ao handle_download pra notificação de progresso
def handle_download(page, ph, url):
    # ... (código anterior)
    total_size = int(response.headers.get("content-length", 0))
    downloaded = 0
    
    with open(save_path, "wb") as f:
        for chunk in response.iter_content(chunk_size=8192):
            downloaded += len(chunk)
            f.write(chunk)
            # Atualiza UI com progresso
            progress = (downloaded / total_size) * 100 if total_size > 0 else 0
            page.show_snack_bar(ft.SnackBar(content=ft.Text(f"Progresso: {progress:.1f}%")))


Get-ChildItem -Recurse | Where-Object { $_.FullName -notmatch "\\.venv\\|__pycache__\\" } | ForEach-Object { $_.FullName } | Out-File -FilePath estrutura_snapdl.txt